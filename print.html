<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Anchor Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1/what_is_anchor.html"><strong aria-hidden="true">1.1.</strong> What is Anchor</a></li><li class="chapter-item expanded "><a href="chapter_1/anchor_documentation.html"><strong aria-hidden="true">1.2.</strong> Anchor Documentation</a></li><li class="chapter-item expanded "><a href="chapter_1/prerequisites.html"><strong aria-hidden="true">1.3.</strong> Prerequisites</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2/getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2/installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="chapter_2/hello_anchor.html"><strong aria-hidden="true">2.2.</strong> Hello, Anchor!</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3/anchor_programs_in-depth.html"><strong aria-hidden="true">3.</strong> Anchor Programs In-Depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3/essentials.html"><strong aria-hidden="true">3.1.</strong> Essentials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3/high-level_overview.html"><strong aria-hidden="true">3.1.1.</strong> High-level Overview</a></li><li class="chapter-item expanded "><a href="chapter_3/the_accounts_struct.html"><strong aria-hidden="true">3.1.2.</strong> The Accounts Struct</a></li><li class="chapter-item expanded "><a href="chapter_3/the_program_module.html"><strong aria-hidden="true">3.1.3.</strong> The Program Module</a></li><li class="chapter-item expanded "><a href="chapter_3/errors.html"><strong aria-hidden="true">3.1.4.</strong> Errors</a></li><li class="chapter-item expanded "><a href="chapter_3/milestone_project_tic-tac-toe.html"><strong aria-hidden="true">3.1.5.</strong> Milestone Project - Tic-Tac-Toe</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Intermediate</div></li></ol></li><li class="chapter-item expanded "><a href="chapter_4/anchor_periphery.html"><strong aria-hidden="true">4.</strong> Anchor Periphery</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_4/cli.html"><strong aria-hidden="true">4.1.</strong> CLI</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> IDL</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Anchor BTS</div></li><li class="spacer"></li><li class="chapter-item expanded "><a href="reference_links.html"><strong aria-hidden="true">6.</strong> Reference Links</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Anchor Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to The Anchor Book! ⚓</p>
<p>This chapter covers what anchor is, how its documentation is structured, and what you should know to have a good time with this guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-anchor"><a class="header" href="#what-is-anchor">What is Anchor</a></h1>
<p>Anchor is a framework for quickly building secure Solana programs.</p>
<p>With Anchor you can build programs quickly because it writes various boilerplate for you such as (de)serialization of accounts and instruction data.</p>
<p>You can build secure programs more easily because Anchor handles certain security checks for you. On top of that, it allows you to succinctly define additional checks and keep them separate from your business logic.</p>
<p>Both of these aspects mean that instead of working on the tedious parts of raw Solana programs, you can spend more time working on what matters most, your product.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anchor-documentation"><a class="header" href="#anchor-documentation">Anchor Documentation</a></h1>
<p>Anchor's official documentation is split up into multiple parts, namely the guide, which is what you are reading right now and the references.</p>
<p>There are three references. One for the <a href="https://docs.rs/anchor-lang/latest/anchor_lang/">core library</a> and one for each official client library (<a href="https://project-serum.github.io/anchor/ts/index.html">typescript</a> and <a href="https://docs.rs/anchor-client/latest/anchor_client/">rust</a>). These references are close to the code and detailed. If you know what you are looking for and want to understand how it works more deeply, you'll find explanations there. </p>
<p>However, if you're new to anchor, you need to know what anchor has to offer before you can even try to understand it more deeply. That's what this guide is for. Its purpose is to introduce you to anchor, to help you become familiar with it. It teaches you what features are available in Anchor so you can explore them yourself in detail using the references.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>This guide (for now) assumes that you already have some knowledge of Solana programs and basic Rust. Ideally, you have already written a basic program without anchor. To make it through the essentials section, you should at least understand <a href="https://docs.solana.com/developing/programming-model/overview">Solana's programming model</a>. Additionally, you should've read chapter 1-9 of the <a href="https://doc.rust-lang.org/book/title-page.html">Rust book</a> which cover the basics of using Rust (Most of the time you don't need advanced Rust to write anchor programs).</p>
<p>If you're not familiar with Solana at all, the official <a href="https://solana.com/developers">Solana developers page</a> is a good starting point.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This chapter walks you through the installation process and the folder structure of an anchor workspace.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>Go <a href="https://www.rust-lang.org/tools/install">here</a> to install Rust.</p>
<h2 id="solana"><a class="header" href="#solana">Solana</a></h2>
<p>Go <a href="https://docs.solana.com/cli/install-solana-cli-tools">here</a> to install Solana.</p>
<h2 id="yarn"><a class="header" href="#yarn">Yarn</a></h2>
<p>Go <a href="https://yarnpkg.com/getting-started/install">here</a> to install Yarn.</p>
<h2 id="anchor"><a class="header" href="#anchor">Anchor</a></h2>
<h3 id="install-using-pre-build-binary-on-x86_64-linux"><a class="header" href="#install-using-pre-build-binary-on-x86_64-linux">Install using pre-build binary on x86_64 Linux</a></h3>
<p>Anchor binaries are available via an NPM package <a href="https://www.npmjs.com/package/@project-serum/anchor-cli"><code>@project-serum/anchor-cli</code></a>. Only <code>x86_64</code> Linux is supported currently, you must build from source for other OS'.</p>
<h3 id="build-from-source-for-other-operating-systems"><a class="header" href="#build-from-source-for-other-operating-systems">Build from source for other operating systems</a></h3>
<p>For now, we can use Cargo to install the CLI.</p>
<pre><code>cargo install --git https://github.com/project-serum/anchor --tag v0.20.1 anchor-cli --locked
</code></pre>
<p>On Linux systems you may need to install additional dependencies if cargo install fails. On Ubuntu,</p>
<pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get install -y pkg-config build-essential libudev-dev
</code></pre>
<p>Now verify the CLI is installed properly.</p>
<pre><code>anchor --version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-anchor"><a class="header" href="#hello-anchor">Hello, Anchor!</a></h1>
<p>To initialize a new project, simply run:</p>
<pre><code>anchor init &lt;new-workspace-name&gt;
</code></pre>
<p>This creates a new anchor workspace you can move into. The following are some of the important files in the folder:</p>
<ul>
<li>The <code>.anchor</code> folder: It includes the most recent program logs and a local ledger that is used for testing</li>
<li>The <code>app</code> folder: An empty folder that you can use to hold your frontend if you use a monorepo</li>
<li>The <code>programs</code> folder: This folder contains your programs. It can contain multiple but initially only contains a program with the same name as <code>&lt;new-workspace-name&gt;</code>. This program already contains a <code>lib.rs</code> file with some sample code.</li>
<li>The <code>tests</code> folder: The folder that contains your E2E tests. It will already include a file that tests the sample code in the <code>programs/&lt;new-workspace-name&gt;</code>.</li>
<li>The <code>migrations</code> folder: In this folder you can save your deploy and migration scripts for your programs.</li>
<li>The <code>Anchor.toml</code> file: This file configures workspace wide settings for your programs. Initially, it configures
<ul>
<li>The addresses of your programs on localnet (<code>[programs.localnet]</code>)</li>
<li>A registry your program can be pushed to (<code>[registry]</code>)</li>
<li>A provider which can be used in your tests (<code>[provider]</code>)</li>
<li>Scripts that Anchor executes for you (<code>[scripts]</code>). The <code>test</code> script is run when running <code>anchor test</code>. You can run your own scripts with <code>anchor run &lt;script_name&gt;</code>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anchor-programs-in-depth"><a class="header" href="#anchor-programs-in-depth">Anchor Programs In-Depth</a></h1>
<p>This section explains how you can use Anchor to build Solana programs. Each section includes code examples, so it is recommended that you start up a new Anchor project before you proceed so you can play around with the code yourself while reading. Call it <code>hello-anchor</code>.</p>
<pre><code>anchor init hello-anchor
</code></pre>
<p>This sections begins with the essentials and then explains more intermediate content afterwards.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="essentials"><a class="header" href="#essentials">Essentials</a></h1>
<p>This chapter teaches you Anchor essentials and includes a milestone project with which you can test your understanding.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="high-level-overview"><a class="header" href="#high-level-overview">High-level Overview</a></h1>
<p>An Anchor program consists of three parts. The <code>program</code> module, the Accounts structs which are marked with <code>#[derive(Accounts)]</code>, and the <code>declareId</code> macro. The <code>program</code> module is where you write your business logic. The Accounts structs is where you validate accounts. The<code>declareId</code> macro creates an <code>ID</code> field that stores the address of your program.</p>
<p>When you start up a new Anchor project, you'll see the following:</p>
<pre><code class="language-rust ignore">// use this import to gain access to common anchor features
use anchor_lang::prelude::*;

// declare an id for your program
declare_id!(&quot;Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS&quot;);

// write your business logic here
#[program]
mod hello_anchor {
    use super::*;
    pub fn initialize(_ctx: Context&lt;Initialize&gt;) -&gt; ProgramResult {
        Ok(())
    }
}

// validate incoming accounts here
#[derive(Accounts)]
pub struct Initialize {}
</code></pre>
<p>We'll go into more detail in the next sections but for now, note that the way an endpoint is connected to its corresponding Accounts struct is the <code>ctx</code> argument in the endpoint. The argument is of type <code>Context</code> which is generic over an Accounts struct, i.e. this is where you put the name of your account validation struct. In this example, it's <code>Initialize</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-accounts-struct"><a class="header" href="#the-accounts-struct">The Accounts Struct</a></h1>
<p>The Accounts struct is where you define which accounts your instruction expects and which constraints these accounts should adhere to. You do this via two constructs: Types and constraints. </p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<blockquote>
<p><a href="https://docs.rs/anchor-lang/latest/anchor_lang/accounts/index.html">Account Types Reference</a></p>
</blockquote>
<p>Each type has a specific use case in mind. Detailed explanations for the types can be found in the <a href="https://docs.rs/anchor-lang/latest/anchor_lang/accounts/index.html">reference</a>.  We will briefly explain the most important type here, the <code>Account</code> type.</p>
<h3 id="the-account-type"><a class="header" href="#the-account-type">The Account Type</a></h3>
<blockquote>
<p><a href="https://docs.rs/anchor-lang/latest/anchor_lang/accounts/account/struct.Account.html">Account Reference</a></p>
</blockquote>
<p>The <code>Account</code> type is used when an instruction is interested in the deserialized data of the account. Consider the following example where we set some data in an account:</p>
<pre><code class="language-rust ignore">use anchor_lang::prelude::*;

declare_id!(&quot;Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS&quot;);

#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context&lt;SetData&gt;, data: u64) -&gt; ProgramResult {
        ctx.accounts.my_account.data = data;
        Ok(())
    }
}

#[account]
#[derive(Default)]
pub struct MyAccount {
    data: u64
}

#[derive(Accounts)]
pub struct SetData&lt;'info&gt; {
    #[account(mut)]
    pub my_account: Account&lt;'info, MyAccount&gt;
}
</code></pre>
<p><code>Account</code> is generic over <code>T</code>. This <code>T</code> is a type you can create yourself to store data. In this example, we have created a struct <code>MyAccount</code> with a single <code>data</code> field to store a <code>u64</code>. Account requires <code>T</code> to implement certain functions (e.g. functions that (de)serialize <code>T</code>). Most of the time, you can use the <code>#[account]</code> attribute to add these functions to your data, as is done in the example.</p>
<p>Most importantly, the <code>#[account]</code> attribute sets the owner of that data to the <code>ID</code> (the one we created earlier with <code>declareId</code>) of the crate <code>#[account]</code> is used in. The Account type can then check for you that the <code>AccountInfo</code> passed into your instruction has its <code>owner</code> field set to the correct program. In this example, <code>MyAccount</code> is declared in our own crate so <code>Account</code> will verify that the owner of <code>my_account</code> equals the address we declared with <code>declareId</code>.</p>
<h4 id="using-accounta-t-with-non-anchor-program-accounts"><a class="header" href="#using-accounta-t-with-non-anchor-program-accounts">Using <code>Account&lt;'a, T&gt;</code> with non-anchor program accounts</a></h4>
<p>There may be cases where you want your program to interact with a non-Anchor program. You can still get all the benefits of <code>Account</code> but you have to write a custom wrapper type instead of using <code>#[account]</code>. For instance, Anchor provides wrapper types for the token program accounts so they can be used with <code>Account</code>. </p>
<pre><code class="language-rust ignore">use anchor_lang::prelude::*;

declare_id!(&quot;Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS&quot;);

#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context&lt;SetData&gt;, data: u64) -&gt; ProgramResult {
        if ctx.accounts.token_account.amount &gt; 0 {
            ctx.accounts.my_account.data = data;
        }
        Ok(())
    }
}

#[account]
#[derive(Default)]
pub struct MyAccount {
    data: u64,
    mint: Pubkey
}

#[derive(Accounts)]
pub struct SetData&lt;'info&gt; {
    #[account(mut)]
    pub my_account: Account&lt;'info, MyAccount&gt;,
    #[account(
        constraint = my_account.mint == token_account.mint,
        has_one = owner
    )]
    pub token_account: Account&lt;'info, TokenAccount&gt;,
    pub owner: Signer&lt;'info&gt;
}
</code></pre>
<p>In this example, we set the <code>data</code> field of an account if the caller has admin rights. We decide whether the caller is an admin by checking whether they own admin tokens for the account they want to change. We do most of this via constraints which we will look at in the next section.
The important thing to take away is that we use the <code>TokenAccount</code> type (that wraps around the token program's <code>Account</code> struct and adds the required functions) to make anchor ensure that the incoming account is owned by the token program and to make anchor deserialize it. This means we can use the <code>TokenAccount</code> properties inside our constraints (e.g. <code>token_account.mint</code>) as well as in the instruction function.</p>
<p>Check out the <a href="https://docs.rs/anchor-lang/latest/anchor_lang/struct.Account.html">reference for the Account type</a> to learn how to implement your own wrapper types for non-anchor programs.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<blockquote>
<p><a href="https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html">Constraints reference</a></p>
</blockquote>
<p>Account types can do a lot of work for you but they're not dynamic enough to handle all the security checks a secure program requires.</p>
<p>Add constraints to an account with the following format:</p>
<pre><code class="language-rust ignore">#[account(&lt;constraints&gt;)]
pub account: AccountType
</code></pre>
<p>Some constraints support custom Errors (we will explore errors <a href="chapter_3/./errors.html">later</a>):</p>
<pre><code class="language-rust ignore">#[account(...,&lt;constraint&gt; @ MyError::MyErrorVariant, ...)]
pub account: AccountType
</code></pre>
<p>For example, in the examples above, we used the <code>mut</code> constraint to indicate that <code>my_account</code> should be mutable. We used <code>has_one</code> to check that <code>token_account.owner == owner.key()</code>. And finally we used <code>constraint</code> to check an arbitrary expression; in this case, whether the incoming <code>TokenAccount</code> belongs to the admin mint.</p>
<pre><code class="language-rust ignore">#[derive(Accounts)]
pub struct SetData&lt;'info&gt; {
    #[account(mut)]
    pub my_account: Account&lt;'info, MyAccount&gt;,
    #[account(
        constraint = my_account.mint == token_account.mint,
        has_one = owner
    )]
    pub token_account: Account&lt;'info, TokenAccount&gt;,
    pub owner: Signer&lt;'info&gt;
}
</code></pre>
<p>You can find information about all constraints in the reference. We will cover some of the most important ones in the milestone project at the end of the Essentials section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-program-module"><a class="header" href="#the-program-module">The Program Module</a></h1>
<p>The program module is where you define your business logic. You do so by writing functions which can be called by clients or other programs. You've already seen one example of such a function, the <code>set_data</code> function from the previous section.</p>
<pre><code class="language-rust ignore">#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context&lt;SetData&gt;, data: u64) -&gt; ProgramResult {
        if ctx.accounts.token_account.amount &gt; 0 {
            ctx.accounts.my_account.data = data;
        }
        Ok(())
    }
}
</code></pre>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<blockquote>
<p><a href="https://docs.rs/anchor-lang/latest/anchor_lang/context/index.html">Context Reference</a></p>
</blockquote>
<p>Each endpoint function takes a <code>Context</code> type as its first argument. Through this context argument it can access the accounts (<code>ctx.accounts</code>), the program id (<code>ctx.program_id</code>) of the executing program, and the remaining accounts (<code>ctx.remaining_accounts</code>). <code>remaining_accounts</code> is a vector that contains all accounts that were passed into the instruction but are not declared in the <code>Accounts</code> struct. This is useful when you want your function to handle a variable amount of accounts, e.g. when initializing a game with a variable number of players.</p>
<h2 id="instruction-data"><a class="header" href="#instruction-data">Instruction Data</a></h2>
<p>If your function requires instruction data, you can add it by adding arguments to the function after the context argument. Anchor will then automatically deserialize the instruction data into the arguments. You can have as many as you like. You can even pass in your own types as long as you use<code>#[derive(AnchorDeserialize)]</code> on them or implement <code>AnchorDeserialize</code> for them yourself. Here's an example with a custom type used as an instruction data arg:</p>
<pre><code class="language-rust ignore">...

#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context&lt;SetData&gt;, data: Data) -&gt; ProgramResult {
        ctx.accounts.my_account.data = data.data;
        ctx.accounts.my_account.age = data.age;
        Ok(())
    }
}

#[account]
#[derive(Default)]
pub struct MyAccount {
    pub data: u64,
    pub age: u8
}

#[derive(AnchorSerialize, AnchorDeserialize, Eq, PartialEq, Clone, Copy, Debug)]
pub struct Data {
    pub data: u64,
    pub age: u8
}

...
</code></pre>
<p>Conveniently, <code>#[account]</code> implements <code>Anchor(De)Serialize</code> for <code>MyAccount</code>, so the example above can be simplified.</p>
<pre><code class="language-rust ignore">...

#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context&lt;SetData&gt;, data: MyAccount) -&gt; ProgramResult {
        ctx.accounts.my_account.set_inner(data);
        Ok(())
    }
}

#[account]
#[derive(Default)]
pub struct MyAccount {
    pub data: u64,
    pub age: u8
}

...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<p>There are three types of errors in anchor programs. Anchor Internal Errors, Custom Errors, and non-anchor errors.</p>
<p>The autogenerated clients can automatically parse Anchor Internal Errors and Custom Errors so they can display the error code and error message. This is not possible for non-anchor errors where clients just return the raw error returned by the underlying solana client libraries.</p>
<blockquote>
<p>(Ultimately, all programs return the same Error: The <a href="https://docs.rs/solana-program/latest/solana_program/program_error/enum.ProgramError.html"><code>ProgramError</code></a>. This Error has a field for a custom error number. This is where Anchor puts its internal and custom error codes. The autogenerated clients read this number and read the IDL (where custom errors' numbers are mapped to their messages) to display the correct error messages (The Anchor internal error number=&gt;message mapping is hardcoded in the clients). Doing it this way means that there is no way to display dynamic custom error messages because all error messages are hardcoded in the IDL. Very soon, anchor will use logs instead of relying only on the returned error code number to emit errors. These logs can also be read by the client and allow dynamic content.)</p>
</blockquote>
<h2 id="anchor-internal-errors"><a class="header" href="#anchor-internal-errors">Anchor Internal Errors</a></h2>
<blockquote>
<p><a href="https://docs.rs/anchor-lang/latest/anchor_lang/__private/enum.ErrorCode.html">Anchor Internal Error Code Reference</a></p>
</blockquote>
<p>Anchor has many different internal error codes. These are not meant to be used by users, but it's useful to study the reference to learn about the mappings between codes and their causes. They are, for example, thrown when a constraint has been violated, e.g. when an account is marked with <code>mut</code> but its <code>is_writable</code> property is <code>false</code>.</p>
<h2 id="custom-errors"><a class="header" href="#custom-errors">Custom Errors</a></h2>
<p>You can add errors that are unique to your program by using the error attribute. </p>
<p>Simply add it to an enum with a name of your choice. You can then use the variants of the enum as errors in your program. Additionally, you can add a message attribute to the individual variants. Clients will then display this error message if the error occurs. Custom Error code numbers start at the <a href="https://docs.rs/anchor-lang/latest/anchor_lang/__private/constant.ERROR_CODE_OFFSET.html">custom error offset</a>.</p>
<pre><code class="language-rust ignore">#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context&lt;SetData&gt;, data: MyAccount) -&gt; ProgramResult {
        if data.data &gt;= 100 {
            return Err(MyError::DataTooLarge.into());    
        }
        ctx.accounts.my_account.set_inner(data);
        Ok(())
    }
}


#[error]
pub enum MyError {
    #[msg(&quot;MyAccount may only hold data below 100&quot;)]
    DataTooLarge
}
</code></pre>
<p>You can use the <a href="https://docs.rs/anchor-lang/latest/anchor_lang/macro.require.html"><code>require</code></a> macro to simplify writing errors. The code above can be simplified to this (Note that the <code>&gt;=</code> flips to <code>&lt;</code>):</p>
<pre><code class="language-rust ignore">#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context&lt;SetData&gt;, data: MyAccount) -&gt; ProgramResult {
        require!(data.data &lt; 100, MyError::DataTooLarge); 
        ctx.accounts.my_account.set_inner(data);
        Ok(())
    }
}


#[error]
pub enum MyError {
    #[msg(&quot;MyAccount may only hold data below 100&quot;)]
    DataTooLarge
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="milestone-project---tic-tac-toe"><a class="header" href="#milestone-project---tic-tac-toe">Milestone Project - Tic-Tac-Toe</a></h1>
<p>You're now ready to build your first anchor project. Create a new anchor workspace with</p>
<pre><code>anchor init tic-tac-toe
</code></pre>
<p>The program will have 2 instructions. First, we need to setup the game. We need to save who is playing it and create a board to play on. Then, the player take turns until there is a winner or a tie.</p>
<h2 id="setting-up-the-game"><a class="header" href="#setting-up-the-game">Setting up the game</a></h2>
<h3 id="state"><a class="header" href="#state">State</a></h3>
<p>Let's begin by thinking about which data we should store. Each game has players, turns, a board, and a game state. This game state describes whether the game is active, tied, or one of the two players won. We can save all this data in an account. This means that each new game will have its own account. Add the following to the bottom of the <code>lib.rs</code> file:</p>
<pre><code class="language-rust ignore">#[account]
pub struct Game {
    players: [Pubkey; 2],          // 64
    turn: u8,                      // 1
    board: [[Option&lt;Sign&gt;; 3]; 3], // 9 * (1 + 1) = 18
    state: GameState,              // 32 + 1
}
</code></pre>
<p>This is the game account. Next to the field definitions, you can see how many bytes each field requires. This will be very important later. Let's also add the <code>Sign</code> and the <code>GameState</code> type.</p>
<pre><code class="language-rust ignore">#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum GameState {
    Active,
    Tie,
    Won { winner: Pubkey },
}

#[derive(
    AnchorSerialize,
    AnchorDeserialize,
    FromPrimitive,
    ToPrimitive,
    Copy,
    Clone,
    PartialEq,
    Eq
)]
pub enum Sign {
    X,
    O,
}
</code></pre>
<p>Both <code>GameState</code> and <code>Sign</code> derive some traits. <code>AnchorSerialize</code> and <code>AnchorDeserialize</code> are the crucial ones. All types that are used in types that are marked with <code>#[account]</code> must implement these two traits (or be marked with <code>#[account]</code> themselves). All other traits are important to our game logic and we are going to use them later. Generally, it is good practice to derive even more traits to make the life of others trying to interface with your program easier (see <a href="https://rust-lang.github.io/api-guidelines/interoperability.html#types-eagerly-implement-common-traits-c-common-traits">Rust's API guidelines</a>) but for brevity's sake, we are not going to do that in this guide.</p>
<p>This won't quite work yet because <code>FromPrimitive</code> and <code>ToPrimitive</code> are unknown. Go to the <code>Cargo.toml</code> file right outside <code>src</code> (not the one at the root of the workspace) and add these two dependencies:</p>
<pre><code class="language-toml">num-traits = &quot;0.2&quot;
num-derive = &quot;0.3&quot;
</code></pre>
<p>Then, import them at the top of <code>lib.rs</code>:</p>
<pre><code class="language-rust ignore">use num_derive::*;
use num_traits::*;
</code></pre>
<h3 id="the-setup-instruction"><a class="header" href="#the-setup-instruction">The Setup Instruction</a></h3>
<p>Before we write any game logic, we can add the instruction that will set up the game in its initial state. Rename the already existing instruction function and accounts struct to <code>setup_game</code> and <code>SetupGame</code> respectively. Now think about which accounts are needed to set up the game. Clearly, we need the game account. Before we can fill it with values, we need to create it. For that, we use the <code>init</code> constraint.</p>
<pre><code class="language-rust ignore">#[derive(Accounts)]
pub struct SetupGame&lt;'info&gt; {
    #[account(init)]
    pub game: Account&lt;'info, Game&gt;
}
</code></pre>
<p><code>init</code> immediately shouts at us and tells us to add a payer. Why do we need it? Because <code>init</code> creates <code>rent-exempt</code> accounts and someone has to pay for that. Naturally, if we want to take money from someone, we should make them sign as well as mark their account as mutable.</p>
<pre><code class="language-rust ignore">#[derive(Accounts)]
pub struct SetupGame&lt;'info&gt; {
    #[account(init, payer = player_one)]
    pub game: Account&lt;'info, Game&gt;,
    #[account(mut)]
    pub player_one: Signer&lt;'info&gt;
}
</code></pre>
<p><code>init</code> is not happy yet. It wants the system program to be inside the struct because <code>init</code> creates the game account by making a call to that program. So let's add it.</p>
<pre><code class="language-rust ignore">#[derive(Accounts)]
pub struct SetupGame&lt;'info&gt; {
    #[account(init, payer = player_one)]
    pub game: Account&lt;'info, Game&gt;,
    #[account(mut)]
    pub player_one: Signer&lt;'info&gt;,
    pub system_program: Program&lt;'info, System&gt;
}
</code></pre>
<p>There's one more thing to do to complete <code>SetupGame</code>. Every account is created with a fixed amount of space. <code>init</code> can try to infer how much space an account needs if it derives <code>Default</code>. So let's implement <code>Default</code> for <code>Game</code></p>
<pre><code class="language-rust ignore">#[account]
#[derive(Default)] &lt;-- add this
pub struct Game {...
</code></pre>
<p>and <code>GameState</code>.</p>
<pre><code class="language-rust ignore">impl Default for GameState {
    fn default() -&gt; Self {
        Self::Active
    }
}
</code></pre>
<p>And with this, <code>SetupGame</code> is complete and we can move on to the <code>setup_game</code> function. (If you like playing detective, you can pause here and try to figure out why what we just did will not work. Hint: Have a look at the <a href="https://borsh.io/">specification</a> of the serialization library Anchor uses. If you cannot figure it out, don't worry. We are going to fix it very soon, together.)</p>
<p>Let's start by adding an argument to the <code>setup_game</code> function.</p>
<pre><code class="language-rust ignore">pub fn setup_game(ctx: Context&lt;SetupGame&gt;, player_two: Pubkey) -&gt; ProgramResult {
    Ok(())
}
</code></pre>
<p>Why didn't we just add <code>player_two</code> as an account in the accounts struct? There are two reasons for this. First, adding it there requires a little more space in the transaction that saves whether the account is writable and whether it's a signer. But we care about neither of that. We just want the address. This brings us to the second and more important reason: Simultaneous network transactions can affect each other if they share the same accounts. For example, if we add <code>player_two</code> to the accounts struct, during our transaction, no other transaction can edit <code>player_two</code>'s account. Therefore, we block all other transactions that want to edit <code>player_two</code>'s account, even though we neither want to read from nor write to the account. We just care about its address!</p>
<p>Finish the instruction function by setting the game to its initial values:</p>
<pre><code class="language-rust ignore">pub fn setup_game(ctx: Context&lt;SetupGame&gt;, player_two: Pubkey) -&gt; ProgramResult {
    let game = &amp;mut ctx.accounts.game;
    game.players = [ctx.accounts.player_one.key(), player_two];
    game.turn = 1;
    Ok(())
}
</code></pre>
<p>Now, run <code>anchor build</code>. On top of compiling your program, this command creates an <a href="https://en.wikipedia.org/wiki/Interface_description_language">IDL</a> for your program. You can find it in <code>target/idl</code>. The anchor typescript client can automatically parse this IDL and generate functions based on it. What this means is that each anchor program gets its own typescript client for free! (Technically, you don't have to call anchor build before testing. <code>anchor test</code> will do it for you.)</p>
<h3 id="testing-the-setup-instruction"><a class="header" href="#testing-the-setup-instruction">Testing the Setup Instruction</a></h3>
<p>Time to test our code! Head over into the <code>tests</code> folder in the root directory. Open the <code>tic-tac-toe.ts</code> file and remove the existing <code>it</code> test. Then, put the following into the <code>describe</code> section:</p>
<pre><code class="language-typescript">  it('setup game!', async() =&gt; {
    const gameKeypair = anchor.web3.Keypair.generate();
    const playerOne = program.provider.wallet;
    const playerTwo = anchor.web3.Keypair.generate();
    await program.rpc.setupGame(playerTwo.publicKey, {
      accounts: {
        game: gameKeypair.publicKey,
        playerOne: playerOne.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId
      },
      signers: [gameKeypair]
    });

    let gameState = await program.account.game.fetch(gameKeypair.publicKey);
    expect(gameState.turn).to.equal(1);
    expect(gameState.players)
      .to
      .eql([playerOne.publicKey, playerTwo.publicKey]);
    expect(gameState.state).to.eql({ active: {} });
    expect(gameState.board)
      .to
      .eql([[null,null,null],[null,null,null],[null,null,null]]);
  });
</code></pre>
<p>and add this to the top of your file:</p>
<pre><code class="language-typescript">import { expect } from 'chai';
</code></pre>
<p>The test begins by creating some keypairs. Importantly, <code>playerOne</code> is not a keypair but the wallet of the program's provider. The provider details are defined in the <code>Anchor.toml</code> file in the root of the project.
Then, we send the transaction. Because the anchor typescript client has parsed the IDL, all transaction inputs have types. If you remove one of the accounts for example, typescript will complain. 
The structure of the transaction function is as follows: First come the instruction arguments. For this function, the public key of the second player. Then come the accounts. Lastly, we add a signers array. We have to add the <code>gameKeypair</code> here because whenever an account gets created, it has to sign its creation transaction. We don't have to add <code>playerOne</code> even though we gave it the <code>Signer</code> type in the program because it is the program provider and therefore signs the transaction by default.</p>
<p>After the transaction returns, we can fetch the state of the game account. You can fetch account state using the <code>program.account</code> namespace. 
Finally, we verify the game has been set up properly. Anchor's typescript client deserializes rust enums like this: <code>{ active: {}}</code> for a fieldless variant and <code>{ won: { winner: Pubkey }}</code> for a variant with fields. The <code>None</code> variant of <code>Option</code> becomes <code>null</code>. The <code>Some(x)</code> variant becomes whatever <code>x</code> deserializes to.</p>
<p>Now, run <code>anchor test</code>. This starts up (and subsequently shuts down) a local validator (make sure you don't have one running) and runs your tests using the test script defined in <code>Anchor.toml</code>.</p>
<h2 id="playing-the-game"><a class="header" href="#playing-the-game">Playing the game</a></h2>
<h3 id="the-play-instruction"><a class="header" href="#the-play-instruction">The Play Instruction</a></h3>
<p>The <code>Play</code> accounts struct is straightforward. We need the game and a player:</p>
<pre><code class="language-rust ignore">#[derive(Accounts)]
pub struct Play&lt;'info&gt; {
    #[account(mut)]
    pub game: Account&lt;'info, Game&gt;,
    pub player: Signer&lt;'info&gt;,
}
</code></pre>
<p><code>player</code> needs to sign or someone else could play for the player.</p>
<p>Next, add the game logic:</p>
<pre><code class="language-rust ignore">impl Game {
    pub fn is_active(&amp;self) -&gt; bool {
        self.state == GameState::Active
    }

    fn current_player_index(&amp;self) -&gt; usize {
        ((self.turn - 1) % 2) as usize
    }

    pub fn current_player(&amp;self) -&gt; Pubkey {
        self.players[self.current_player_index()]
    }

    pub fn play(&amp;mut self, tile: &amp;Tile) -&gt; ProgramResult {
        if !self.is_active() {
            return Err(TicTacToeError::GameAlreadyOver.into());
        }
        match tile {
            tile
            @ Tile {
                row: 0..=2,
                column: 0..=2,
            } =&gt; match self.board[tile.row as usize][tile.column as usize] {
                Some(_) =&gt; return Err(TicTacToeError::TileAlreadySet.into()),
                None =&gt; {
                    self.board[tile.row as usize][tile.column as usize] =
                        Some(Sign::from_usize(self.current_player_index()).unwrap());
                }
            },
            _ =&gt; return Err(TicTacToeError::TileOutOfBounds.into()),
        }

        self.update_state();

        if let GameState::Active = self.state {
            self.turn += 1;
        }

        Ok(())
    }

    fn is_winning_trio(&amp;self, trio: [(usize, usize); 3]) -&gt; bool {
        let [first, second, third] = trio;
        self.board[first.0][first.1].is_some()
            &amp;&amp; self.board[first.0][first.1] == self.board[second.0][second.1]
            &amp;&amp; self.board[first.0][first.1] == self.board[third.0][third.1]
    }

    fn update_state(&amp;mut self) {
        for i in 0..=2 {
            // three of the same in one row
            if self.is_winning_trio([(i, 0), (i, 1), (i, 2)]) {
                self.state = GameState::Won {
                    winner: self.current_player(),
                };
                return;
            }
            // three of the same in one column
            if self.is_winning_trio([(0, i), (1, i), (2, i)]) {
                self.state = GameState::Won {
                    winner: self.current_player(),
                };
                return;
            }
        }

        // three of the same in one diagonal
        if self.is_winning_trio([(0, 0), (1, 1), (2, 2)])
            || self.is_winning_trio([(0, 2), (1, 1), (2, 0)])
        {
            self.state = GameState::Won {
                winner: self.current_player(),
            };
            return;
        }

        // reaching this code means the game has not been won,
        // so if there are unfilled tiles left, it's still active
        for row in 0..=2 {
            for column in 0..=2 {
                if self.board[row][column].is_none() {
                    return;
                }
            }
        }

        // game has not been won
        // game has no more free tiles
        // -&gt; game ends in a tie
        self.state = GameState::Tie;
    }
}
</code></pre>
<p>We are not going to explore this code in detail together because it's rather simple rust code. It's just tic-tac-toe after all! Roughly, what happens when <code>play</code> is called:</p>
<ol>
<li>Return error if game is over or
return error if given row or column are outside the 3x3 board or
return error if tile on board is already set</li>
<li>Determine current player and set tile to X or O</li>
<li>Update game state</li>
<li>If game is still active, increase the turn</li>
</ol>
<p>Currently, the code doesn't compile because we need to add the <code>Tile</code></p>
<pre><code class="language-rust ignore">#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct Tile {
    row: u8,
    column: u8,
}
</code></pre>
<p>and the <code>TicTacToeError</code> type.</p>
<pre><code class="language-rust ignore">#[error]
pub enum TicTacToeError {
    TileOutOfBounds,
    TileAlreadySet,
    GameAlreadyOver,
    NotPlayersTurn,
}
</code></pre>
<p>Finally, we can add the <code>play</code> function inside the program module.</p>
<pre><code class="language-rust ignore">pub fn play(ctx: Context&lt;Play&gt;, tile: Tile) -&gt; ProgramResult {
    let game = &amp;mut ctx.accounts.game;

    require!(
        game.current_player() == ctx.accounts.player.key(),
        TicTacToeError::NotPlayersTurn
    );

    game.play(&amp;tile)
}
</code></pre>
<p>We've checked in the accounts struct that the <code>player</code> account has signed the transaction, but we do not check that it is the <code>player</code> we expect. That's what the <code>require</code> check in <code>play</code> is for.</p>
<h3 id="testing-the-play-instruction"><a class="header" href="#testing-the-play-instruction">Testing the Play Instruction</a></h3>
<p>Testing the <code>play</code> instruction works the exact same way. To avoid repeating yourself, create a helper function at the top of the test file:</p>
<pre><code class="language-typescript">async function play(program, game, player,
    tile, expectedTurn, expectedGameState, expectedBoard) {
  await program.rpc.play(tile, {
    accounts: {
      player: player.publicKey,
      game
    },
    signers: player instanceof (anchor.Wallet as any) ? [] : [player]
  });

  const gameState = await program.account.game.fetch(game);
  expect(gameState.turn).to.equal(expectedTurn);
  expect(gameState.state).to.eql(expectedGameState);
  expect(gameState.board)
    .to
    .eql(expectedBoard);
}
</code></pre>
<p>You can create then a new <code>it</code> test, setup the game like in the previous test, but then keep calling the <code>play</code> function you just added to simulate a complete run of the game. Let's begin with the first turn:</p>
<pre><code class="language-typescript">it('player one wins', async() =&gt; {
    const gameKeypair = anchor.web3.Keypair.generate();
    const playerOne = program.provider.wallet;
    const playerTwo = anchor.web3.Keypair.generate();
    await program.rpc.setupGame(playerTwo.publicKey, {
      accounts: {
        game: gameKeypair.publicKey,
        playerOne: playerOne.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId
      },
      signers: [gameKeypair]
    });

    let gameState = await program.account.game.fetch(gameKeypair.publicKey);
    expect(gameState.turn).to.equal(1);
    expect(gameState.players)
      .to
      .eql([playerOne.publicKey, playerTwo.publicKey]);
    expect(gameState.state).to.eql({ active: {} });
    expect(gameState.board)
      .to
      .eql([[null,null,null],[null,null,null],[null,null,null]]);

    await play(
      program,
      gameKeypair.publicKey,
      playerOne,
      {row: 0, column: 0},
      2,
      { active: {}, },
      [
        [{x:{}},null,null],
        [null,null,null],
        [null,null,null]
      ]
    );
});
</code></pre>
<p>Now run <code>anchor test</code> again and you will be greeted with an error:</p>
<pre><code>Error: 3004: Failed to serialize the account
</code></pre>
<p>What to do? We know that it happens during play, because our <code>setupGame</code> test runs fine.
Also, it says <code>serialize</code>, not <code>deserialize</code>. So after our logic runs and anchor tries to save all the data, there is an error.
What this means most of the time is that the account is too small to hold all its data and this is also the problem here.</p>
<p>Let's have a look at the <code>Game</code> struct again and the way we created it:</p>
<pre><code class="language-rust ignore">#[account]
#[derive(Default)]
pub struct Game {
    players: [Pubkey; 2],          // 64
    turn: u8,                      // 1
    board: [[Option&lt;Sign&gt;; 3]; 3], // 9 * (1 + 1) = 18
    state: GameState,              // 32 + 1
}

...
#[account(init, payer = player_one)]
pub game: Account&lt;'info, Game&gt;,
...

</code></pre>
<p>Remember that we implemented <code>Default</code> for <code>Game</code> because <code>init</code> can try to infer the correct space requirements based on <code>Default</code>, &quot;try&quot; being the operative word. What happens if we don't specify an explicit <code>space</code> requirement for the account is that anchor will call <code>default</code> on the account and convert it to a vector using borsh. It then uses the length of that vector as the space for the account.
Let's walk through our example step by step using the <a href="https://borsh.io/">borsh specification</a>. The comments show us the space requirements that we must get, that is, the largest the given type can become.</p>
<ul>
<li>Pubkey as a vector has a length of <code>32</code> so <code>2*32 = 64</code> ✅</li>
<li>u8 as a vector has a length of <code>1</code> so <code>1 = 1</code> ✅</li>
<li>board's default (<code>9 * None</code>) as a vector has a length of <code>9 != 18</code> ❌</li>
<li>state's default as a vector is <code>1 != 33</code> ❌</li>
</ul>
<p>We have found out that <code>init</code> currently only allocates 75 bytes for our account data but the account can grow to (64 + 1 + 18 + 33) = 116 bytes.
We can add this number to our Game impl like this:</p>
<pre><code class="language-rust ignore">impl Game {
    const MAXIMUM_SIZE: usize = 116;

    ... // other functions
}
</code></pre>
<pre><code class="language-rust ignore">...
#[account(init, payer = player_one, space = Game::MAXIMUM_SIZE + 8)]
pub game: Account&lt;'info, Game&gt;,
...
</code></pre>
<p>In addition to the game's size, we have to add another <code>8</code> to the space. This is space for the <code>discriminator</code> which anchor sets automatically. In short, the discriminator is how anchor can differentiate between different accounts of the same program.</p>
<blockquote>
<p>(What about using <code>mem::size_of&lt;Game&gt;()</code>? This almost works but not quite. The issue is that borsh will always serialize an option as 1 byte for the variant identifier and then additional x bytes for the content if it's Some. Rust uses null-pointer optimization to make Option's variant identifier 0 bytes when it can, so an option is sometimes just as big as its contents. This is the case with <code>Sign</code>. This means the <code>MAXIMUM_SIZE</code> could be expressed as <code>mem::size_of&lt;Game&gt;() + 9</code>.)</p>
</blockquote>
<p>Running <code>anchor test</code> should work now. You can finish writing the test by yourself. Try to simulate a win and a tie!</p>
<p>Proper testing also includes tests that try to exploit the contract. You can check whether you've protected yourself properly by calling <code>play</code> with unexpected parameters. For example:</p>
<pre><code class="language-typescript">try {
  await play(
    program,
    gameKeypair.publicKey,
    playerTwo,
    {row: 5, column: 1}, // out of bounds row
    4,
    { active: {}, },
    [
      [{x:{}},{x: {}},null],
      [{o:{}},null,null],
      [null,null,null]
    ]
  );
  // we use this to make sure we definitely throw an error
  chai.assert(false, &quot;should've failed but didn't &quot;);
} catch (error) {
  expect(error.code).to.equal(6000);
}
</code></pre>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<p>Solana has three main clusters: <code>mainnet-beta</code>, <code>devnet</code>, and <code>testnet</code>.
For developers, <code>devnet</code> and <code>mainnet-beta</code> are the most interesting. <code>devnet</code> is where you test your application in a more realistic environment than <code>localnet</code>. <code>testnet</code> is mostly for validators.</p>
<p>We are going to deploy on <code>devnet</code>.</p>
<p>Here is your deployment checklist 🚀</p>
<ol>
<li>Run <code>anchor build</code>. Your program keypair is now in <code>target/deploy</code>. Keep this secret. You can reuse it on all clusters.</li>
<li>Run <code>solana address -k target/deploy/tic_tac_toe-keypair.json</code> and copy the address into your <code>declare_id!</code> macro at the top of <code>lib.rs</code>.</li>
<li>Run <code>anchor build</code> again. This step is necessary to include our new program id in the binary.</li>
<li>Change the <code>provider.cluster</code> variable in <code>Anchor.toml</code> to <code>devnet</code>.</li>
<li>Run <code>anchor deploy</code></li>
<li>Run <code>anchor test</code></li>
</ol>
<p>There is more to deployments than this e.g. understanding how the BPFLoader works, how to manage keys, how to upgrade your programs and more. Keep reading to learn more!</p>
<p>Well done! You've finished the essentials section. You can now move on to the more advanced parts of Anchor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anchor-periphery"><a class="header" href="#anchor-periphery">Anchor Periphery</a></h1>
<p>This chapter explores Anchor's periphery.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli"><a class="header" href="#cli">CLI</a></h1>
<p>A CLI is provided to support building and managing an Anchor workspace.
For a comprehensive list of commands and options, run <code>anchor -h</code> on any
of the following subcommands.</p>
<pre><code>anchor-cli

USAGE:
    anchor &lt;SUBCOMMAND&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    build      Builds the workspace
    cluster    Cluster commands
    deploy     Deploys each program in the workspace
    expand     Expands the macros of a program or the workspace
    help       Prints this message or the help of the given subcommand(s)
    idl        Commands for interacting with interface definitions
    init       Initializes a workspace
    migrate    Runs the deploy migration script
    new        Creates a new program
    test       Runs integration tests against a localnetwork
    upgrade    Upgrades a single program. The configured wallet must be the upgrade authority
    verify     Verifies the on-chain bytecode matches the locally compiled artifact. Run this
               command inside a program subdirectory, i.e., in the dir containing the program's
               Cargo.toml
</code></pre>
<h2 id="build"><a class="header" href="#build">Build</a></h2>
<pre><code>anchor build
</code></pre>
<p>Builds programs in the workspace targeting Solana's BPF runtime and emitting IDLs in the <code>target/idl</code> directory.</p>
<pre><code>anchor build --verifiable
</code></pre>
<p>Runs the build inside a docker image so that the output binary is deterministic (assuming a Cargo.lock file is used). This command must be run from within a single crate subdirectory within the workspace. For example, <code>programs/&lt;my-program&gt;/</code>.</p>
<h2 id="cluster"><a class="header" href="#cluster">Cluster</a></h2>
<h3 id="cluster-list"><a class="header" href="#cluster-list">Cluster list</a></h3>
<pre><code>anchor cluster list
</code></pre>
<p>This lists cluster endpoints:</p>
<pre><code>Cluster Endpoints:

* Mainnet - https://solana-api.projectserum.com
* Mainnet - https://api.mainnet-beta.solana.com
* Devnet  - https://api.devnet.solana.com
* Testnet - https://api.testnet.solana.com
</code></pre>
<h2 id="deploy"><a class="header" href="#deploy">Deploy</a></h2>
<pre><code>anchor deploy
</code></pre>
<p>Deploys all programs in the workspace to the configured cluster.</p>
<p>::: tip Note
This is different from the <code>solana program deploy</code> command, because everytime it's run
it will generate a <em>new</em> program address.
:::</p>
<h2 id="expand"><a class="header" href="#expand">Expand</a></h2>
<pre><code>anchor expand
</code></pre>
<p>If run inside a program folder, expands the macros of the program.</p>
<p>If run in the workspace but outside a program folder, expands the macros of the workspace.</p>
<p>If run with the <code>--program-name</code> option, expand only the given program.</p>
<h2 id="idl"><a class="header" href="#idl">Idl</a></h2>
<p>The <code>idl</code> subcommand provides commands for interacting with interface definition files.
It's recommended to use these commands to store an IDL on chain, at a deterministic
address, as a function of nothing but the the program's ID. This
allows us to generate clients for a program using nothing but the program ID.</p>
<h3 id="idl-init"><a class="header" href="#idl-init">Idl Init</a></h3>
<pre><code>anchor idl init -f &lt;target/idl/program.json&gt; &lt;program-id&gt;
</code></pre>
<p>Creates an idl account, writing the given <code>&lt;target/idl/program.json&gt;</code> file into a program owned account. By default, the size of the account is double the size of the IDL,
allowing room for growth in case the idl needs to be upgraded in the future.</p>
<h3 id="idl-fetch"><a class="header" href="#idl-fetch">Idl Fetch</a></h3>
<pre><code>anchor idl fetch -o &lt;out-file.json&gt; &lt;program-id&gt;
</code></pre>
<p>Fetches an IDL from the configured blockchain. For example, make sure
your <code>Anchor.toml</code> is pointing to the <code>mainnet</code> cluster and run</p>
<pre><code>anchor idl fetch GrAkKfEpTKQuVHG2Y97Y2FF4i7y7Q5AHLK94JBy7Y5yv
</code></pre>
<h3 id="idl-authority"><a class="header" href="#idl-authority">Idl Authority</a></h3>
<pre><code>anchor idl authority &lt;program-id&gt;
</code></pre>
<p>Outputs the IDL account's authority. This is the wallet that has the ability to
update the IDL.</p>
<h3 id="idl-erase-authority"><a class="header" href="#idl-erase-authority">Idl Erase Authority</a></h3>
<pre><code>anchor idl erase-authority -p &lt;program-id&gt;
</code></pre>
<p>Erases the IDL account's authority so that upgrades can no longer occur. The
configured wallet must be the current authority.</p>
<h3 id="idl-upgrade"><a class="header" href="#idl-upgrade">Idl Upgrade</a></h3>
<pre><code>anchor idl upgrade &lt;program-id&gt; -f &lt;target/idl/program.json&gt;
</code></pre>
<p>Upgrades the IDL file on chain to the new <code>target/idl/program.json</code> idl.
The configured wallet must be the current authority.</p>
<pre><code>anchor idl set-authority -n &lt;new-authority&gt; -p &lt;program-id&gt;
</code></pre>
<p>Sets a new authority on the IDL account. Both the <code>new-authority</code> and <code>program-id</code>
must be encoded in base 58.</p>
<h2 id="init"><a class="header" href="#init">Init</a></h2>
<pre><code>anchor init
</code></pre>
<p>Initializes a project workspace with the following structure.</p>
<ul>
<li><code>Anchor.toml</code>: Anchor configuration file.</li>
<li><code>Cargo.toml</code>: Rust workspace configuration file.</li>
<li><code>package.json</code>: JavaScript dependencies file.</li>
<li><code>programs/</code>: Directory for Solana program crates.</li>
<li><code>app/</code>: Directory for your application frontend.</li>
<li><code>tests/</code>: Directory for JavaScript integration tests.</li>
<li><code>migrations/deploy.js</code>: Deploy script.</li>
</ul>
<h2 id="migrate"><a class="header" href="#migrate">Migrate</a></h2>
<pre><code>anchor migrate
</code></pre>
<p>Runs the deploy script located at <code>migrations/deploy.js</code>, injecting a provider configured
from the workspace's <code>Anchor.toml</code>. For example,</p>
<pre><code class="language-javascript">// File: migrations/deploys.js

const anchor = require(&quot;@project-serum/anchor&quot;);

module.exports = async function (provider) {
  anchor.setProvider(provider);

  // Add your deploy script here.
}
</code></pre>
<p>Migrations are a new feature
and only support this simple deploy script at the moment.</p>
<h2 id="new"><a class="header" href="#new">New</a></h2>
<pre><code>anchor new &lt;program-name&gt;
</code></pre>
<p>Creates a new program in the workspace's <code>programs/</code> directory initialized with boilerplate.</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<pre><code>anchor test
</code></pre>
<p>Run an integration test suit against the configured cluster, deploying new versions
of all workspace programs before running them.</p>
<p>If the configured network is a localnet, then automatically starts the localnetwork and runs
the test.</p>
<p>::: tip Note
Be sure to shutdown any other local validators, otherwise <code>anchor test</code> will fail to run.</p>
<p>If you'd prefer to run the program against your local validator use <code>anchor test --skip-local-validator</code>.
:::</p>
<p>When running tests we stream program logs to <code>.anchor/program-logs/&lt;address&gt;.&lt;program-name&gt;.log</code></p>
<p>::: tip Note
The Anchor workflow <a href="https://www.parity.io/paritys-checklist-for-secure-smart-contract-development/">recommends</a>
to test your program using integration tests in a language other
than Rust to make sure that bugs related to syntax misunderstandings
are coverable with tests and not just replicated in tests.
:::</p>
<h2 id="upgrade"><a class="header" href="#upgrade">Upgrade</a></h2>
<pre><code>anchor upgrade &lt;target/deploy/program.so&gt; --program-id &lt;program-id&gt;
</code></pre>
<p>Uses Solana's upgradeable BPF loader to upgrade the on chain program code.</p>
<h2 id="verify"><a class="header" href="#verify">Verify</a></h2>
<pre><code>anchor verify &lt;program-id&gt;
</code></pre>
<p>Verifies the on-chain bytecode matches the locally compiled artifact.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-links"><a class="header" href="#reference-links">Reference Links</a></h1>
<ul>
<li><a href="https://docs.rs/anchor-lang/latest/anchor_lang/accounts/index.html">Accounts Reference</a></li>
<li><a href="https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html">Constraints Reference</a></li>
<li><a href="https://docs.rs/anchor-lang/latest/anchor_lang/__private/enum.ErrorCode.html">Error Codes</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
